(load "library/replication")
(load "library/utilities")
(load "library/simple-components")
{include-component "library/identity"}
{include-component "library/math"}

;;; Here are a couple fun things to try when you load this file:
;;;
;;; {include-component "library/simple-io"}
;;;
;;; {natural-numbers {echo}}
;;; {fibonacci-numbers {echo}}
;;; {primes {echo}}

;; This is a simple sequence generator. Given an initial value, it will send
;; that over `rc`, perform the given operation on the value, send the new value
;; to `rc`, etc.
(trigger* {generate-sequence (tup ?initial-value {?operation} {?rc})}
  (new next
    {rc initial-value
    (trigger {next ?value}
      {generate-sequence (tup value {operation} {rc})})}
    {operation (tup initial-value {next})}))

;; Should probably put this in the math library
(trigger* {successor (tup ?value {?rc})}
  {+ (tup value 1 {rc})})

;; sends all integers starting from `start` over `rc`.
(trigger* {generate-integers (tup ?start {?rc})}
  {generate-sequence (tup start {successor} {rc})})

;; sends all the natural numbers over `rc`.
(trigger* {natural-numbers {?rc}}
  {generate-integers (tup 1 {rc})})

;; This sequence is too complex to use the pre-defined generate-sequence for, so
;; it's written out in full.
(trigger* {generate-fibonacci (tup ?a ?b {?rc})}
  (new next
    {+ (tup a b {next})}
    (trigger {next ?value}
      (cont {rc a} {generate-fibonacci (tup b value {rc})}))))

;; Sends all the fibonacci numbers over `rc`.
(trigger* {fibonacci-numbers {?rc}}
  {generate-fibonacci (tup 0 1 {rc})})

;; A simple filter that will check all values sent over `in`, and if they are
;; _not_ divisible by `factor`, it will send them over `rc`.
(trigger* {filter-multiples (tup {?in} ?factor {?rc})}
  (trigger {in ?value}
    (new mod
      {modulus (tup value factor {mod})}
      (trigger {mod ?rem}
        {/= (tup rem 0
                 (cont {rc value} {filter-multiples (tup {in} factor {rc})})
                 {filter-multiples (tup {in} factor {rc})})}))))

;; The sieve of Erastothenes
(trigger* {sieve (tup {?in} {?rc})}
  (trigger {in ?value}
    (cont {rc value}
          (new next-in
            {filter-multiples (tup {in} value {next-in})}
            {sieve (tup {next-in} {rc})}))))

;; Sends all prime numbers over `rc`.
(trigger* {primes {?rc}}
  (new connection
    {generate-integers (tup 2 {connection})}
    {sieve (tup {connection} {rc})}))

;; Send the `index`th value in a stream over `rc`.
(trigger* {stream-ref (tup {?in} ?index {?rc})}
  (trigger {in ?value}
    {= (tup index 0
            {rc value}
            (new next
              {- (tup index 1 {next})}
              (trigger {next ?next}
                {stream-ref (tup {in} next {rc})})))}))

;; `stream-ref` allows us to redefine the example from fibonacci.kiln as
(trigger* {fibonacci (tup ?index {?rc})}
  (new f
    {fibonacci-numbers {f}}
    {stream-ref (tup {f} index {rc})}))

;;; You can see how sharing a channel makes the producer/consumer pattern very
;;; simple.
