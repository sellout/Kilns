(load "library/test-framework")
(load "library/utilities")

;;; NOTE: Normally I would just (load "examples/...") in each test, however most
;;;       examples want to print a result, and we want to capture the result
;;;       instead. So these are copied from the examples instead.

;;; helloworld.kiln
{test-result {should {be-hello-world}}
             {test {echo "Hello World"}}
             {expected-result {echo "Hello World"}}}

;;; higherorder.kiln
{test-result {should {execute-received-message}}
             {test (new a
                     {a {echo "Hello World"}}
                     (trigger {a ?x} x))}
             {expected-result {echo "Hello World"}}}

;;; location.kiln
{test-result {should {pull-signal-out-of-nested-kell}}
             {test (new (a signal b)
                     [b (trigger (up {a}) {signal})]
                     {a}
                     (trigger (down {signal}) {echo "Hello World"}))}
             {expected-result {echo "Hello World"}}}

;;; simplemessage.kiln
;;; FIXME: this test is non-deterministic. It would be nice if we could specify
;;;       “x OR y” as the expected-result
{test-result {should {trigger-once}}
             {test (new a
                     {a "Hello"}
                     {a "World"}
                     (trigger {a ?x} {echo x}))}
             {expected-result {echo "Hello"}}}

;;; synchronous.kiln
{test-result {should {concatenate-message}}
             {test (new a
                     (load "library/simple-components")
                     {include-component "library/strings"}
                     (new r
                       {a (list "hello " "world" {r})}
                       (trigger {r ?x} {echo x}))
                     (trigger {a (list ?x ?y {?r})}
                       {string-concat (list x y {r})}))}
             {expected-result {echo "hello world"}}}
