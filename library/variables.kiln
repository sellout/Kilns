(load "library/replication")
(load "library/utilities")

;;; From the paper “Representation of Programming Constructs with the Kell-m
;;; Calculus”

(trigger* {var {?name ?value}}
  (trigger {name (tup {?r} {?u})}
    (new (q t c)
      [q (trigger {r {?rc}}
           {stop {t}} {rc ?value} {c {name value}})]
      [t (trigger {u ?newval}
           {stop {q}} {c {name ?newval}})]
      (trigger (down {c {?n ?val}}) {var {n val}}))))

(trigger* {set {?name ?value}}
  (new (r u)
    {name (tup {r} {u})}
    {u ?value}))

(trigger* {get (tup {?name} {?rc})}
  (new (r u)
    {name (tup {r} {u})}
    {r {?rc}}))

;;; Below is a possible shorthand sequence for when you are getting a value to
;;; then use in a process
;;;
;;; (@ get (tup {v2}) ?value {set {v1 ?value}})
;;; =>
;;; (new rc
;;;      (par {get (tup {v2} {rc})}
;;;           (trigger {rc ?value} {set {v1 ?value}})))

(new rc
  (def (@ channel parameters values process)
    `(new rc
       {,channel (tup ,@parameters {rc})}
       (trigger {rc ,values} ,process)))

  (trigger* {@ (tup {?channel} ?parameters ?values ?process)}
    (new rc
      {channel (tup parameters {rc})}
      (trigger {rc values} process)))

  (def (@* channel parameters values process)
    `(new rc
       {,channel (tup ,@parameters {rc})}
       (trigger* {rc ,values} ,process))))

;;; and an even shorter hand for treating things like they return values
;;;
;;; (@ set {v1 (@ get {v2})})
;;; =>
;;; (new rc
;;;   {get (tup {v2} {rc})}
;;;   (trigger {rc ?value} {set {v1 ?value}}))
