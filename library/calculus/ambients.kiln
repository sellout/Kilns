(load "library/replication")
(load "library/utilities")

(define (Collector)
  (trigger* {collect (tup {?a} {?k} ?p)}
    (trigger [a ?x]
      (new (r b)
        (F {a} {k} {r})
        [b (trigger (par [a ?x]
                         {query (tup {a} {k} {r})}
                         {r (tup {a} {k} {?b})})
             {r (tup {a} {k} {b})})]))))

(define (F {?a} {?k} {?r})
  (trigger {r (tup {a} {k} {yes})} (trigger [b ?y] ?p))
  (trigger {r (tup {a} {k} {no})}
    (trigger [b ?y]
      {collect (tup {a} {k})}
      [a ?x])))

;;; Isn't this good enough?
(define (Collector)
  (trigger* (down {collect {?kell}})
    (trigger [kell ?x] null)))

;;;       ⟦null⟧ = null
;;;  ⟦(new n P)⟧ = (new n ⟦P⟧)
;;;   ⟦(par P Q⟧ = (par ⟦P⟧ ⟦Q⟧)
;;;      ⟦(! P)⟧ = (new a (par {a} (trigger {a} (par ⟦P⟧ {a}))))
;;;      ⟦[a P]⟧ = (par [a (par (A a) [amb ⟦P⟧])] (AmbEnv))
;;;   ⟦(in a P)⟧ = {in (tup a ⟦P⟧)}
;;;  ⟦(out a P)⟧ = {out (tup a ⟦P⟧)}
;;; ⟦(open a P)⟧ = {open (tup a ⟦P⟧)}

(define (A {?a}) ; NB: This looks just like a pi-calc alternative.
  (new t
    {t}
    (S {a} {t})
    (T {a} {t})
    (F {a} {t})
    (NQ {a} {t})))

(define (S ?a {?t})
  (trigger (par {t} (down {in (tup ?b ?p)}))
    (trigger [amb ?z]
      (new k
        {collect (tup {a} {k} {to (tup {a} {in} ?m p z)})}
        (YQ {a} {k}))))
  (trigger (par {t} (down {out (tup ?b ?p)}))
    (trigger [amb ?z]
      (new k
        {collect (tup {a} {k} {up (tup {a} {out} ?m p z)})}
        (YQ {a} {k})))))
