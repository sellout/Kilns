(new (lambda fun arg abs)
     ;;            [[x]] = x
     ;; [[(lambda x P)]] = {abs (trigger {lambda x} [[P]])}
     ;;        [[(P Q)]] = (new (fun arg) (par (App) [fun [[P]]] {arg [[Q]]}))
     (par (def (lambda (var) process)
              `{abs (trigger {lambda (process-variable ',var)} ,process)})
          (def (apply fun arg)
              `(new (fun arg)
                    (par (App)
                         [fun ,fun]
                         {arg ,arg})))
          (def (App)
              `(trigger (par [fun {abs ?p}] {arg ?q})
                        (par ?p {lambda ?q})))))

#| encoding from the πCalculus book – keep around until we know the new one
   works

(load "library/replication")
(load "library/utilities")

;;; pi-calculus [!P] replication, needed to implement the pi-calc encoding of
;;; the lambda-calc. There might be a more direct encoding - anyone want to tell
;;; me what it is?
(trigger* {replicate {?name ?process}}
          {?name ?process {replicate {?name ?process}}})

;;;     [[x]](u) = {x u}
;;;  [[lx M]](u) = (trigger {u (list ?x ?v)} [[M]]<v>)
;;; [[(M N)]](u) = (new v (par [[M]]<v>
;;;                            (new x (par {v (list x u)}
;;;                                        {replicate {x [[N]]}}))))
(def (translate-lambda-term term channel)
  (cl:if (cl:listp term)
    (cl:if (cl:eql (cl:first term) 'lambda)
      ;; lambda
      `(trigger {,channel (list {(name-variable ',(cl:second term))} {?v})}
                (translate-lambda-term ,(cl:third term) ?v))
      ;; apply
      (cl:let ((v (cl:gensym "v"))
               (x (cl:gensym "x")))
        `(new ,v
              (par (translate-lambda-term ,(cl:first term) ,v)
                   (new ,x
                        (par {,v (par {,x} {,channel})}
                             {replicate {,x (translate-lambda-term ,(cl:second term) ,v)}}))))))
    ;; variable
    `{(name-variable ',term) {,channel}}))

|#
