(load "library/utilities")
(load "library/sandbox")

(trigger* (up {zero (tup {?f} ?x {?rc})}) {rc x})
(trigger* (up {succ (tup {?n} {?name})})
  (trigger* {name (tup {?f} ?x {?rc})}
    (new s
      {f (tup x {s})}
      (trigger {s ?result}
        {n (tup {f} result {rc})))))
{succ (tup {zero} {one})} ;; need this guy to implement `exp`
(trigger* (up {plus (tup {?m} {?n} {?name})})
  {m (tup {succ} {n} {name})})
(trigger* (up {mult (tup {?m} {?n} {?name})})
  {sandbox (tup (new plusn
                  (trigger* {plusn (tup {?o} {?rc})}
                    {plus (tup {n} {o} {rc})})
                  {m (tup {plusn} {zero} {name})})
                {name})})
(trigger* (up {exp (tup {?m} {?n} {?name})})
  {sandbox (tup (new multn
                  (trigger* {multn (tup {?o} {?rc})}
                    {mult (tup {n} {o} {rc})})
                  {m (tup {multn} {one} {name}))}
                {name})})
(trigger* (up {pred (tup {?n} {?name})})
  (trigger* {name (tup {?f} ?x {?rc})}
    (new (gh ux uu)
      (trigger* {gh (tup {?g} {?h} {?ghrc})}
        (new grc
          {g (tup {f} {grc})}
          (trigger {grc ?y} {h (tup y {ghrc})})))
      (trigger* {ux (tup {?u} {?uxrc})} {uxrc x})
      (trigger* {uu (tup {?u} {?uurc})} {uurc {u}})
      {n (tup {gh} {ux} {uu})})))
(trigger* (up {sub (tup {?m} {?n} {?name})})
  {n (tup {pred} {m} {name})})
(trigger* (up {zerop (tup {?n} {?rc})})
  {sandbox (tup (new s
                  (trigger {s (tup ?x {?norc})} {rc {false}})
                  {n (tup {s} {true} {rc})})
                {rc})})

;; Convert between native and church representations
(trigger* (up {church (tup {0} {?rc})}) {rc {zero}})
(trigger* (up {church (tup {(/= 0 ?integer)} {?rc})})
  (new (sub pred)
    {- (tup ?integer {1} {sub})}
    (trigger {sub ?dec} {church (tup dec {pred})})
    (trigger {pred ?prev} {succ (tup prev {rc})})))
(trigger* (up {unchurch (tup ?church {?rc})})
  (trigger* {inc (tup ?n {?rinc})} {rinc (lisp (cl:1+ #.?n))})
  {n (tup {inc} 0 {rc})})
