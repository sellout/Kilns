(load "library/replication")
(load "library/utilities")

;;; IO can not be implemented directly in the calculus, so we need to call out
;;; to lisp to actually read and write. This library provides a few basic tools
;;; for reading and writing.

#|
Rather than locking in the implementation for every print, each stream should
have a semaphore message created along with it, so we can do

(trigger* (up {read (tup ?stream {?rc})})
  (trigger {stream-semaphore stream}
    (new token
      {token (lisp (kilns::read stream))}
      (trigger {token ?tok}
        {rc tok}
        {stream-semaphore stream}))))

The idea being that when there's a request to read from a particular stream, we
grab the semaphore for that stream, then try to read. When we get the resulting
token, we send it over `rc` and re-create the semaphore.

In general, the less the implementation has to do, the better. So now we don't
need to lock.
|#

(trigger* (up {echo ?string})
  (lisp (kilns::printk "~a~%" string) null))

(trigger* (up {read {?rc}})               {rc (lisp (kilns::read))})
(trigger* (up {read (tup ?stream {?rc})}) {rc (lisp (kilns::read stream))})

(trigger* (up {read-string {?rc}}) {rc (lisp (cl:read-line))})


(trigger* (up {write ?process}) (lisp (cl:write process)))
(trigger* (up {write (tup ?process ?stream)})
          (lisp (cl:write process :stream stream)))
