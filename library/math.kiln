(load "library/replication")
(load "library/utilities")
(load "library/identity")
(load "library/ordering")

;; primitives

(trigger* (up {+ (list ?augend ?addend {?rc})})
          (lisp (cl:let ((sum (cl:+ augend addend)))
                  {component-out {rc sum}})))
(trigger* (up {- (list ?minuend ?subtrahend {?rc})})
          (lisp (cl:let ((difference (cl:- minuend subtrahend)))
                  {component-out {rc difference}})))
(trigger* (up {* (list ?multiplier ?multiplicand {?rc})})
          (lisp (cl:let ((product (cl:* multiplier multiplicand)))
                  {component-out {rc product}})))
(trigger* (up {/ (list ?dividend ?divisor {?rc})})
          (lisp (cl:let ((quotient (cl:/ dividend divisor)))
                  {component-out {rc quotient}})))
(trigger* (up {remainder (list ?number ?divisor {?rc})})
          (lisp (cl:let ((remainder (cl:rem number divisor)))
                  {component-out {rc remainder}})))

;; derived

(trigger* (up {zerop (list ?number ?true ?false)})
          {= (list number 0 {component-out true} {component-out false})})

(trigger* (up {plusp (list ?number ?true ?false)})
          {< (list 0 number {component-out true} {component-out false})})

(trigger* (up {minusp (list ?number ?true ?false)})
          {< (list number 0 {component-out true} {component-out false})})


(trigger* (up {modulus (list ?number ?divisor {?rc})})
          (new rem
               (par {component-local {remainder (list number divisor {rem})}}
                    (trigger {rem ?remain up}
                             {component-local {zerop (list remain
                                                           {rc remain}
                                                           {minusp (list divisor
                                                                         {plusp (list number
                                                                                      {+ (list remain divisor {rc})}
                                                                                      {rc remain})}
                                                                         {minusp (list number
                                                                                       {+ (list remain divisor {rc})}
                                                                                       {rc remain})})})}}))))

(trigger* {evenp (list ?integer ?true ?false) up}
          (new bin
               (par {component-local {modulus (list integer 2 {bin})}}
                    (trigger (up {bin ?binary})
                             {= (list binary 2
                                      {component-out true}
                                      {component-out false})}))))

#|
(trigger* {abs (list ?number {?rc})}
          {complexp (list ?number
                          (new (part pow sum)
                               (par {realpart (list ?number {part})}
                                    {imagpart (list ?number {part})}
                                    ;; need to clean up
                                    (trigger* {part ?part}
                                              {expt (list ?part 2 {pow})})
                                    (trigger (par {pow ?a} {pow ?b})
                                             {+ (list ?a ?b {sum})})
                                    (trigger {sum ?sum}
                                             {sqrt (list ?sum {rc})})))
                          {minusp (list ?number
                                        {- (list ?number {rc})}
                                        {rc ?number})})})

(trigger* {conjugate (list ?complex {?rc})}
          (par {realpart (list ?complex {real})}
               {imagpart (list ?complex {imag})}
               (trigger {imag ?real} {- (list ?real {ima})})
               (trigger (par {real ?r} {ima ?i}) {complex (list ?r ?i {rc})})))

;;(trigger* {least-common-multiple (list ?a ?b {?rc})}

(trigger* {signum (list ?number {?rc})}
          {zerop (list ?number
                       {rc ?number}
                       (new ab
                            (par {abs (list ?number {ab})}
                                 (trigger {ab ?val} {/ ?number ?val}))))})

(trigger* {tan (list ?number {?rc})}
          (new (s c)
               (par {sin ?number {s}}
                    {cos ?number {c}}
                    (trigger (par {s ?s} {c ?c}) {/ (list ?s ?c {rc})}))))
|#
