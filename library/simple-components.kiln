(load "library/replication")

;;; This file implements a very basic component model that allows for sending
;;; either qualified or unqualified messages to the component. It is not a rich
;;; model, but it illustrates the simplicity with which components can be
;;; realized.
;;;
;;; In this model, a component is a file that contains (among other things)
;;; triggers at the top level that match on {?x ?y up}. These can be equated to
;;; public methods or exported functions.

;;; A message sent over `component-out` will be passed out of the component back
;;; to the parent kell. This is useful for sending responses.

;;; You need to use `component-local` if you want to send a message to a trigger
;;; that's part of your component's public interface (since they are all
;;; listening for up-messages, you need to get the message out of the kell
;;; first).

;;; NOTE: if you wrap a call in `component-local`, you shouldn't wrap its
;;;       responses in `component-out`, since the local call you're making will
;;;       do that itself.

;;; `include-component` will allow you to send messages that match those
;;; triggers directly. EG, if there is a trigger in the component that matches
;;; "{echo ?string up}", then {echo "test"} will cause a reaction with it. This
;;; gives you direct access, but you need to be careful that the "exported"
;;; triggers don't conflict with your own triggers. This is similar to :USEing
;;; the component in a Common Lisp DEFPACKAGE.
(def (include-component filename)
     `(new component (par (trigger* {component-out ?out down} ?out)
                          (trigger* {component-local ?local down} ?local)
                          [component (load ,filename)])))

;;; `load-component` gives you better isolation, but requires that you "qualify"
;;; the message with the name of the kell you pass in. Using the same example as
;;; above, if you name the component "io", then you need to send the message
;;; {io {echo "test"}} to cause a reaction in the component. With this version,
;;; you only need to ensure that {io ...} doesn't conflict with your own
;;; triggers. Nothing the component writer does can interfere with your other
;;; messages and triggers.
(def (load-component filename prefix)
     (cl:let ((kellname (cl:gensym (cl:symbol-name prefix))))
       `(new ,kellname
             (par (trigger* {component-out ?out down} ?out)
                  [,kellname (par (trigger* {,prefix ?message up} ?message)
                                  (trigger* {component-local ?local down} ?local)
                                  (trigger* {component-out ?out down} {component-out ?out})
                                  [,kellname (load ,filename)])]))))

#|
;;; `replace-component` replaces the component named `prefix` with the contents
;;; of `filename`.
(def (replace-component filename prefix)
     `(trigger [,prefix _]
               (load-component ,filename ,prefix)))

;;; `remove-component` completely removes the component that uses the given
;;; prefix
(def (remove-component prefix)
     `(trigger [,prefix _] null))

;;; It may be possible to implement these as messages rather than macros, but
;;; one thing you lose is the globalness -- you have to load this file in each
;;; kell from which you'd like to use it. Another issue is that cleaning up
;;; might be messy.

(new (outer-replace-component outer-remove-component)
     (par (trigger* {load-component (par {filename ?filename}
                                         {prefix {?prefix}})}
                    (new component
                         (par [component (par (trigger* {?prefix ?message up}
                                                        ?message)
                                              [component (load #.?filename)]
                                              (trigger {replace-component ?file up}
                                                       {outer-replace-component
                                                        (par {filename ?file}
                                                             {prefix ?prefix}
                                                             {component-name {component}})})
                                              (trigger {remove-component up}
                                                       {outer-remove-component
                                                        {component}}))])))
          (trigger* {outer-replace-component (par {filename ?filename}
                                                  {prefix {?prefix}}
                                                  {component-name {?component}})
                                             down}
                    (trigger [?component _]
                             {load-component (par {filename ?filename}
                                                  {prefix {?prefix}})}))
          (trigger* {outer-remove-component {?component} down}
                    (trigger [?component _] null))))

;;; With this approach, you can do

{load-component (par {filename "xml-component"} {prefix {xml}})}
{xml {replace-component "new-xml-component"}}
{xml {remove-component}}
|#
